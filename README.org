#+TITLE: Readme
#+PROPERTY: header-args :tangle project2.jl
#+STARTUP: showeverything

* Entangled Quantum Cuckoo search for multi-objective quadratic multi-knapsack problem

* TODO Project Roadmap
SCHEDULED: <2021-10-20 Wed>
- [X] Import Data from Website
- [X] Implement Levy Flights
- [X]  Make Levy Flights work in Binary Solution Space
- [X] Implement quantum behavior
- [X] Rewrite functions to work with new data structure.
- [X] Fix pareto filter code.
- [X] Make sure data is readable from stdin.
- [X] Implement cuckoo search method for knapsack data
- [ ] Updated pareto filter to reject invalid solutions.
- [ ] Evaluate Performance
- [ ] Make plots and write report

* Imports
#+begin_src julia
using Distributions, Chain, Random, Plots, StatsBase, CSV, DataFrames, ArgParse, StatsPlots
#+end_src

* Levy Flights
#+begin_src julia
normalize(x)=x/sum(x)
function replace_sols(sol,qb)
    temp=sol[1]
    flight=Levy(0,0.02)
    dist=sample(5:length(temp),Weights(normalize(rand(flight,length(temp)-5))))
    ind=sample(1:length(temp),dist,replace=false)
    temp[ind]=1 .- temp[ind]
   return quantum_unentanglement(temp,qb)
end
#+end_src

* Pareto Filtering
#+begin_src julia
#Working as expected.
# Upgrading to work with new data struct.
# In progress, needs testing.
function pareto_filter(y::AbstractArray)
x=mapreduce(z->z[2],hcat,y)
d,n=size(x)
io=repeat([true],n)
    for i∈ 1:n-1, j∈ i:n
        if i!=j && (io[i] || io[j])
            xi=x[:,i]
            xj=x[:,j]
            if all(xi .<= xj) && any(xi .< xj)
                io[j]=false
            elseif all(xj .<= xi) && any(xj .< xi)
                io[i]=false
            end
        end
    end
    return io
end
#+end_src

* Quantum Operators
#+begin_src julia
# Working as expected
function measure(qv)
    return reshape(map(x->rand()>abs2(qv[x][2]) ? 1 : 0, 1:length(qv)),:,size(qv)[2])
end

#Working as expected.
function interfere!(qv,sol,pa=pi/20)
    for i in 1:length(qv)
        scale=i_lookup(real(qv[i][1]),real(qv[i][2]),sol[i])
        pa=scale*pa
        rot_mat=[cos(pa) -sin(pa); sin(pa) cos(pa)]
        qv[i]=rot_mat*qv[i]
    end
    return qv
end

# Working as expected
# Tested already.
function i_lookup(a,b,c)
    if a>0 && b >0 && c==1
        return(1)
    elseif a>0 && b >0 && c==0
        return(-1)
    elseif a>0 && b <0 && c==1
        return(-1)
    elseif a>0 && b <0 && c==0
        return(1)
    elseif a<0 && b >0 && c==1
            return(-1)
    elseif a<0 && b >0 && c==0
        return(1)
    elseif a<0 && b <0 && c==1
        return(1)
    else
        return(-1)
    end
end

# Working as expected
function iq_mutate!(qv)
    pos=rand(1:length(qv))
    a=qv[pos][1]
    b=qv[pos][2]
    qv[pos][2]=a
    qv[pos][1]=b
    return qv
end

# Working as expected
function eq_mutate!(qv)
    p1,p2=rand(1:length(qv),2)
    t1=qv[p1]
    t2=qv[p2]
    qv[p1]=t2
    qv[p2]=t1
    return qv
end
#+end_src

#+RESULTS:

* Defining Superposition Quantum Vectors
#+begin_src julia
# This creates normalized qbits who's complex probabilities sum to 1.
# Working as expected
function ab(x,n)
    a=rand(x*n)+rand(x*n)*im
    b=rand(x*n)+rand(x*n)*im
    return reshape(map(y->[a[y]/sqrt(abs2(a[y])+abs2(b[y])),b[y]/sqrt(abs2(a[y])+abs2(b[y]))],1:x*n),:,n)
end
#+end_src

* Quantum Unentanglement Function
#+begin_src julia
# Working as expected
# Used to convert quantum matrix to probability matrix
# for disentanglement.
function prob_one(cuckoo)
    return abs2.(map(x->x[2],cuckoo))
end

#Working as expected
#Repairs invalid solutions
function quantum_unentanglement(knapsack, q, profits, weight, capacity)
    knapsacks1=knapsack'
    qb=q'
    weights = weight'
    prob_sum, prob_list, r, p_over_w = 0, [], 0, []
    for i = 1:size(knapsacks1,2)
        if sum([knapsacks1[j,i] for j = 1:size(knapsacks1,1)]) > 1
            cpd, index = 0, -1
            prob_sum = sum([qb[j,i] for j = 1:size(qb,1)])
            prob_list = [qb[j,i]/prob_sum for j = 1:size(qb,1)]
            r = rand()
            for k = 1:size(prob_list, 1)
                cpd = cpd + prob_list[k]
                if r < cpd && index == -1
                    index = k
                end
            end
            for k = 1:size(knapsacks1, 1)
                if k == index
                    knapsacks1[k,i] = 1
                else
                    knapsacks1[k,i] = 0
                end
            end
        end
    end
    for i=1:size(knapsacks1,1)
        if sum([knapsacks1[i,j]*weights[1,j] for j = 1:size(knapsacks1,2)]) > capacity
            p_over_w = [(profits[1,j]/weights[1,j])*knapsacks1[i,j] for j = 1:size(knapsacks1,2)]
            sortedindicespw = sortperm(p_over_w)
            k = 1
            while (sum([knapsacks1[i,j]*weights[1,j] for j = 1:size(knapsacks1,2)]) > capacity) && (k <= length(sortedindicespw))
                knapsacks1[i,sortedindicespw[k]] = 0
                k = k + 1
            end
        end
    end
    return knapsacks1
end
#+end_src

* Fitness Evaluation Function
#+begin_src julia
#Does what it says on the tin.
function knapsack_capacity(knapsacks, weights)
    total_weight = sum(weights)
    no_of_knapsacks = knapsacks
    return 0.8*total_weight/no_of_knapsacks
end

#Computes values of objective functions
# Returns all negative values to make this
# a minimization problem across the board
# values will be corrected during analyses.
function multi_fitness_values(knapsack, profit, weight, capacity)
    knapsacks=deepcopy(knapsack)'
    weights=deepcopy(weight)'
    profits_fitness_list = []
    weights_list = []
    penalty=maximum(profit[1,:] ./ weights')
    for i = 1:size(knapsacks,1)
        fitness = 0
        weight = 0
        for j = 1:size(knapsacks,2)
            fitness = fitness + knapsacks[i,j]*profit[1,j]
            weight = weight + knapsacks[i,j]*weights[1,j]
            if knapsacks[i,j] == 1 && j < size(knapsacks,2)
                for k = (j+1):size(knapsacks,2)
                    if knapsacks[i,k] == 1
                        fitness = fitness + profit[j+1, k]
                    end
                end
            end
        end
        if weight > capacity
            fitness = fitness - (weight - capacity)*penalty
        end
        append!(profits_fitness_list, fitness)
        append!(weights_list, weight)
    end
    return [-sum(profits_fitness_list), sum(weights_list), -minimum(profits_fitness_list)]
end

# Takes list of pareto front values
# and plots a boxplot of the 3 objective values.
function plot_pareto_front(front)
    a=mapreduce(x->front[x][2],hcat,1:length(front))
    a[1,:]=(-1).*a[1,:]
    a[3,:]=(-1).*a[3,:]
    boxplot(a')
end

# Takes measured solutions
# and evaluates them, and returns a new data structure.
function score_solutions(sols::Vector{Matrix{Int64}},profits,weights,capacity)::Vector{Vector{Array}}
    vals=map(x->multi_fitness_values(x,profits,weights,capacity),sols)
    temp=collect.(zip(sols,vals))
    return temp
end
#+end_src

* CLI Argument Handling and Data Ingestion
#+begin_src julia
function parse_commandline()
    s = ArgParseSettings()
    @add_arg_table! s begin
        "--mut_prob1", "-m"
            help = "mutation probability 1"
            arg_type = Float64
            default = 0.5
        "--mut_prob2", "-n"
            help = "mutation probability 1"
            arg_type = Float64
            default = 0.5
        "--knapsacks", "-k"
            help = "number of knapsacks"
            arg_type = Int
            default = 3
        "--phaseangle", "-p"
            help = "Phase angle"
            arg_type = Float64
            default = pi/20
        # "--flag1"
        #     help = "an option without argument, i.e. a flag"
        #     action = :store_true
        "file"
            help = "a positional argument"
            required = true
    end
    return parse_args(s)
end

function parse()
    parsed_args = parse_commandline()
    println("Parsed args:")
    for (arg,val) in parsed_args
        println("  $arg  =>  $val")
    end
    # code to assign the parsed args
    file =  parsed_args["file"]
    mut_prob1 = parsed_args["mut_prob1"]
    mut_prob2 = parsed_args["mut_prob2"]
    knapsacks = parsed_args["knapsacks"]
    phaseangle = parsed_args["phaseangle"]
    return file, mut_prob1, mut_prob2, knapsacks, phaseangle
end


function quadratic_formatting(Q::AbstractMatrix)
    nrows,ncols = size(Q)
    #ncols = size(Q, 2)
    for i in 1:nrows
        temp = Q[i, 1:(ncols-i)]
        Q[i, 1:i] = Q[i, (ncols - i + 1):ncols]
        Q[i, (i+1):ncols] = temp
    end
    return Q
end

function input(f)
    df = CSV.read(f, DataFrame, header = 0, skipto=2, delim=" ", ignorerepeated=true, footerskip=4, silencewarnings=true)
    df = mapcols(col->replace(col, missing=>0), df)
    # for i in 1:ncol(df)
    #     df[!, i] = convert_or_parse.(df[!,i])
    # end
    # number of items
    n = df[1, 1]
    b = Array(df[2, :])
    Q = Array(df[3:(n+2), :])
    Q = quadratic_formatting(Q)
    Q = Q[1:n-1,:]
    #matrix with regular and quadratic coefficients
    coeff = vcat(b', Q)
    #weights of the items
    w = Array(df[nrow(df), :])
    return n, coeff, w
end

#+end_src

* Create Function Composition to Run Simulation
#+begin_src julia
function search(cuckoo, profits, weights, mut_prob1, mut_prob2, pa, capacity,cycles, iter)
    qb = prob_one(cuckoo)
    sols=[measure(cuckoo) for _ in 1:cycles]
    sols=map(x->quantum_unentanglement(x,qb),sols)
    sols=score_solutions(sols,profits,weights,capacity)
    nondominated=sols[pareto_filter(sols)]
    replaced=map(y->replace_sols(y,qb),sols[map(x->!x,pareto_filter(sols))])
    replaced=score_solutions(replaced,profits,weights,capacity)
    nondominated=vcat(nondominated,replaced)[pareto_filter(vcat(nondominated,replaced))]
    count=0
    while count<iter
        if(rand()<mut_prob1)
            iq_mutate!(cuckoo)
        end
        if(rand()<mut_prob2)
            eq_mutate!(cuckoo)
        end
        interfere!(cuckoo,sample(nondominated)[1],pa)
        qb = prob_one(cuckoo)
        sols=[measure(cuckoo) for _ in 1:cycles]
        sols=score_solutions(map(x->quantum_unentanglement(x,qb),sols),profits,weights,capacity)
        nondominated=vcat(nondominated,sols)[pareto_filter(vcat(nondominated,sols))]
        replaced=score_solutions(map(y->replace_sols(y,qb),sols[map(x->!x,pareto_filter(sols))]),profits,weights,capacity)
        nondominated=vcat(nondominated,replaced)[pareto_filter(vcat(nondominated,replaced))]
        count+=1
    end
    return unique(nondominated)
end

function main()
    file, mut_prob1, mut_prob2, n_knapsacks, phaseangle = parse()
    n_items,profits,weights=input(file);
    cuckoo=ab(n_items,n_knapsacks)
    cap=knapsack_capacity(n_knapsacks, weights)
    cycles=500
    iter=200
    out=search(cuckoo,profits,weights,mut_prob1,mut_prob2,phaseangle,cap,cycles,iter)
    savefig(plot_pareto_front(out),file*"plot.png")
end

main()

#+end_src

* References of Interest
https://www-sciencedirect-com.ezproxy.lib.purdue.edu/science/article/pii/S0957417417308217
https://www-sciencedirect-com.ezproxy.lib.purdue.edu/science/article/pii/S1568494620310152?casa_token=36zagcogZDkAAAAA:weBL0ohC_du_vqfYamDz2vdrnaovcRWkk3fmKPcNFbJEGSD8VxhgxwEcBNNrNbOLx27p4mmqNg#tbl6
https://www.researchgate.net/publication/250309677_A_Novel_Greedy_Quantum_Inspired_Cuckoo_Search_Algorithm_for_variable_sized_Bin_Packing_Problem
