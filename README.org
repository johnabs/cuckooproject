#+TITLE: Readme
#+PROPERTY: header-args :tangle project.jl
#+STARTUP: showeverything

* Entangled Quantum Cuckoo search for multi-objective quadratic multi-knapsack problem

* TODO Project Roadmap
SCHEDULED: <2021-10-20 Wed>
- [ ] Import Data from Website
- [ ] Implement Levy Flights
- [ ] Implement quantum behavior
- [ ] Implement cuckoo search method for knapsack data
- [ ] Evaluate Performance
- [ ] Make plots and write report

* Imports
#+begin_src julia
using Distributions.jl, Chain, Random
#+end_src

* Levy Flights
#+begin_src julia
flight=Levy()

#+end_src

* Pareto Filtering
#+begin_src julia
function pareto_filter(x::AbstractArray)
	d,n=size(x)
	io=repeat([true],n)
	for i∈ 1:n-1, j∈ i:n
		if i!=j && (io[i] || io[j])
			xi=x[:,i]
			xj=x[:,j]
			if all(xi<= xj) && any(xi<xj)
				io[j]=false
			elseif all(xj<= xi) && any(xj<xi)
				io[i]=false
			end

		end
	end
	return(x[:,io])
end
#+end_src

* Quantum Operators
#+begin_src julia
function measure(qv)
    return map(x->rand()>abs2(qv[x][2]) ? 1 : 0, 1:size(qv)[1])
end

function interfere(qv,sol)
    pa=pi/20

    rot_mat=[cos(pa) -sin(pa); sin(pa), cos(pa)]


end

function iq_mutate(qv)

end

function eq_mutate(qv)

end
#+end_src

#+RESULTS:

* Defining Superposition Quantum Vectors
#+begin_src julia
n=50
# This creates normalized qbits who's complex probabilities sum to 1.
function ab(x)
           a=rand(x)+rand(x)*im
           b=rand(x)+rand(x)*im
           return map(y->[a[y]/sqrt(abs2(a[y])+abs2(b[y])),b[y]/sqrt(abs2(a[y])+abs2(b[y]))],1:x)
       end
qvec=
#+end_src

* Quantum Unentanglement Function
#+begin_src julia
using Random

qb = [0.91 0.78 0.22 0.4 0.48 0.85 0.46 0.81 0.3 0.26; 0 0.55 0.23 0.35 0.44 0.5 0.91 0.95 0.26 0.40; 0 0 0.92 0.11 0.20 0.43 0.71 0.83 0.27 0.65]
knapsacks1 = [1 0 0 1 0 1 0 1 0 0; 1 1 0 1 1 0 1 1 0 0; 1 0 0 1 0 0 0 1 0 0]

function quantum_unentanglement(knapsacks1, qb)
    prob_sum, prob_list, r = 0, [], 0
    for i = 1:size(knapsacks1,2)
        if sum([knapsacks2[j,i] for j = 1:size(knapsacks2,1)]) > 1
            cpd, index = 0, -1
            prob_sum = sum([qb[j,i] for j = 1:size(qb,1)])
            prob_list = [qb[j,i]/prob_sum for j = 1:size(qb,1)]
            r = rand()
            for k = 1:size(prob_list, 1)
                cpd = cpd + prob_list[k]
                if r < cpd && index == -1
                    index = k
                end
            end
            for k = 1:size(knapsacks1, 1)
                if k == index
                    knapsacks1[k,i] = 1
                else
                    knapsacks1[k,i] = 0
                end
            end
        end
    end
    return knapsacks1
end

println(knapsacks1)
println(quantum_unentanglement(knapsacks1, qb))
#+end_src

* Fitness Evaluation Function
#+begin_src julia
knapsacks = [1 0 0 1 0 1 0 0 0 0; 0 1 0 0 1 0 1 1 0 0; 0 0 1 0 0 0 0 0 1 1]
profits = [91 78 22 4 48 85 46 81 3 26; 0 55 23 35 44 5 91 95 26 40; 0 0 92 11 20 43 71 83 27 65; 0 0 0 7 57 33 38 57 63 82; 0 0 0 0 100 87 91 83 44 48; 0 0 0 0 0 69 57 79 89 21; 0 0 0 0 0 0 9 40 22 26; 0 0 0 0 0 0 0 50 6 7; 0 0 0 0 0 0 0 0 71 52; 0 0 0 0 0 0 0 0 0 17]
weights = [34 33 12 3 43 26 10 2 48 39]

function knapsack_capacity(knapsacks, weights)
    total_weight = sum(weights)
    no_of_knapsacks = size(knapsacks,1)
    return 0.8*total_weight/no_of_knapsacks
end

capacity = knapsack_capacity(knapsacks, weights)

function multi_fitness_values(knapsacks, profits, weights, capacity)
    profits_fitness_list = []
    weights_list = []
    for i = 1:size(knapsacks,1)
        fitness = 0
        weight = 0
        for j = 1:size(knapsacks,2)
            fitness = fitness + knapsacks[i,j]*profits[1,j]
            weight = weight + knapsacks[i,j]*weights[1,j]
            if knapsacks[i,j] == 1 && j < size(knapsacks,2)
                for k = (j+1):size(knapsacks,2)
                    if knapsacks[i,k] == 1
                        fitness = fitness + profits[j+1, k]
                    end
                end
            end
        end
        if weight > capacity
            fitness = fitness - (weight - capacity)*(maximum(profits))
        end
        append!(profits_fitness_list, fitness)
        append!(weights_list, (-1)*weight)
    end
    return [sum(profits_fitness_list), sum(weights_list), minimum(profits_fitness_list)]
end

println(multi_fitness_values(knapsacks, profits, weights, capacity))
#+end_src

#+RESULTS:

* Example Julia Code
#+begin_src julia :eval no-export :results output :exports both
a=collect(1:10)
for i in 1:10
    if i%2==0
        a[i]=a[i]^2
    end
end
a
#+end_src

#+RESULTS:
#+begin_example
10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
10-element Vector{Int64}:
   1
   4
   3
  16
   5
  36
   7
  64
   9
 100
#+end_example


* References of Interest
https://www-sciencedirect-com.ezproxy.lib.purdue.edu/science/article/pii/S0957417417308217
https://www-sciencedirect-com.ezproxy.lib.purdue.edu/science/article/pii/S1568494620310152?casa_token=36zagcogZDkAAAAA:weBL0ohC_du_vqfYamDz2vdrnaovcRWkk3fmKPcNFbJEGSD8VxhgxwEcBNNrNbOLx27p4mmqNg#tbl6
https://www.researchgate.net/publication/250309677_A_Novel_Greedy_Quantum_Inspired_Cuckoo_Search_Algorithm_for_variable_sized_Bin_Packing_Problem
